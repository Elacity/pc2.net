<!DOCTYPE html>
<html lang="en">

<head>
    <meta name="description" content="" />
    <meta charset="utf-8">
    <title>Editor</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="author" content="">
    <!-- CSS -->
    <link rel="stylesheet" href="./css/normalize.css">
    <link rel="stylesheet" href="./css/printjs.min.css">
    <link rel="stylesheet" href="./css/style.css">
    <!-- Preload images -->
    <link rel="preload" as="image" href="./img/check-active.svg">
    <link rel="preload" as="image" href="./img/check.svg">
    <link rel="preload" as="image" href="./img/icon.svg">

    <meta name="viewport" content="width=device-width, initial-scale=1">
</head>

<body>
    <!-- editor -->
    <div id="editor"></div>
    <!-- status bar -->
    <div class="status-bar">
        <div class="doc-stats" style="float:left; display:none; margin-left:10px;">
            Paragraphs: <span id="paragraph-count">0</span>, 
            Words: <span id="word-count">0</span>, 
            Letters: <span id="letter-count">0</span>
        </div>
        Line <span id="pos-line">1</span>, Column <span id="pos-column">1</span>
    </div>
    <!-- hidden file input element -->
    <div style="display:none;">
        <input type="file" id="file-input" />
        <h3>Contents of the file:</h3>
        <pre id="file-content"></pre>
    </div>
    <!-- printer -->
    <pre id="printer"></pre>
    <!-- JS -->
    <script>
        // CRITICAL: Intercept API calls BEFORE SDK loads to redirect to PC2 node
        (function() {
            const urlParams = new URLSearchParams(window.location.search);
            const apiOrigin = urlParams.get('puter.api_origin') || window.location.origin;
            const appInstanceId = urlParams.get('puter.app_instance_id');
            
            // Store app instance ID globally for SDK to use
            if (appInstanceId) {
                window.puterAppInstanceID = appInstanceId;
                // Also store in a way the SDK might expect
                window.puterAppInstanceId = appInstanceId;
            }
            
            const originalFetch = window.fetch;
            window.fetch = function(...args) {
                let url = args[0];
                if (typeof url === 'string' && url.includes('api.puter.')) {
                    args[0] = url.replace(/https?:\/\/api\.puter\.[^\/:]+(?::\d+)?/gi, apiOrigin);
                } else if (url && typeof url === 'object' && url.url && url.url.includes('api.puter.')) {
                    url.url = url.url.replace(/https?:\/\/api\.puter\.[^\/:]+(?::\d+)?/gi, apiOrigin);
                }
                return originalFetch.apply(this, args);
            };
            
            const originalXHROpen = XMLHttpRequest.prototype.open;
            XMLHttpRequest.prototype.open = function(method, url, ...rest) {
                if (typeof url === 'string' && url.includes('api.puter.')) {
                    url = url.replace(/https?:\/\/api\.puter\.[^\/:]+(?::\d+)?/gi, apiOrigin);
                }
                return originalXHROpen.call(this, method, url, ...rest);
            };
        })();
    </script>
    <script src="./js/puter-sdk/puter-sdk-v2.js"></script>
    <script>
        // Initialize Puter SDK and ensure appInstanceID is included in messages
        (function() {
            const urlParams = new URLSearchParams(window.location.search);
            const authToken = urlParams.get('puter.auth.token');
            const apiOrigin = urlParams.get('puter.api_origin');
            const appInstanceId = urlParams.get('puter.app_instance_id');
            
            // Store app instance ID globally
            if (appInstanceId) {
                window.puterAppInstanceID = appInstanceId;
                console.log('[Editor]: ‚úÖ App instance ID from URL:', appInstanceId);
            }
            
            function initializeSDK() {
                if (typeof puter === 'undefined') {
                    setTimeout(initializeSDK, 10);
                    return;
                }
                
                if (authToken) {
                    try {
                        puter.setAuthToken(authToken);
                        console.log('[Editor]: ‚úÖ Auth token set from URL params');
                    } catch (e) {
                        console.error('[Editor]: Failed to set auth token:', e);
                    }
                }
                
                if (apiOrigin) {
                    try {
                        puter.setAPIOrigin(apiOrigin);
                        console.log('[Editor]: ‚úÖ API origin set to:', apiOrigin);
                    } catch (e) {
                        console.error('[Editor]: Failed to set API origin:', e);
                    }
                }
                
                // CRITICAL: Patch puter.fs.read() to convert ~ paths to full paths
                // The backend API doesn't understand ~ paths, so we need to convert them
                if (puter && puter.fs && puter.fs.read) {
                    const originalRead = puter.fs.read.bind(puter.fs);
                    puter.fs.read = async function(options) {
                        // Handle both object and string path formats
                        let pathToRead = null;
                        if (typeof options === 'string') {
                            pathToRead = options;
                        } else if (options && typeof options === 'object' && options.path) {
                            pathToRead = options.path;
                        } else if (options && typeof options === 'object' && options.uid) {
                            // If uid is provided, use it directly (no path conversion needed)
                            return await originalRead(options);
                        }
                        
                        // Convert ~ path to full path if needed
                        if (pathToRead && pathToRead.startsWith('~/')) {
                            console.log('[Editor]: üîß Converting ~ path to full path:', pathToRead);
                            
                            const urlParams = new URLSearchParams(window.location.search);
                            
                            // Priority 1: ALWAYS try to get fresh readURL using uid (for latest content after save)
                            // This ensures reopened files show the latest saved content
                            const itemUid = urlParams.get('puter.item.uid');
                            let usedFreshReadURL = false;
                            
                            if (itemUid && puter && puter.fs && puter.fs.stat) {
                                try {
                                    console.log('[Editor]: üîÑ ALWAYS fetching fresh metadata using uid:', itemUid);
                                    const statResult = await puter.fs.stat({ uid: itemUid, consistency: 'strong' });
                                    console.log('[Editor]: üìä stat() result:', statResult);
                                    
                                    // Extract readURL from stat result (might be nested)
                                    let freshReadURL = null;
                                    if (statResult && statResult.readURL) {
                                        freshReadURL = statResult.readURL;
                                    } else if (statResult && statResult.read_url) {
                                        freshReadURL = statResult.read_url;
                                    } else if (statResult && statResult.result && statResult.result.readURL) {
                                        freshReadURL = statResult.result.readURL;
                                    } else if (statResult && statResult.result && statResult.result.read_url) {
                                        freshReadURL = statResult.result.read_url;
                                    }
                                    
                                    if (freshReadURL) {
                                        console.log('[Editor]: ‚úÖ Using fresh readURL from stat():', freshReadURL);
                                        // Add cache-busting parameter to ensure we get the latest content
                                        const url = new URL(freshReadURL);
                                        url.searchParams.set('_t', Date.now());
                                        const cacheBustedURL = url.toString();
                                        console.log('[Editor]: üîÑ Fetching with cache-busting:', cacheBustedURL);
                                        const response = await fetch(cacheBustedURL);
                                        if (!response.ok) {
                                            throw new Error(`Failed to read file: ${response.statusText}`);
                                        }
                                        usedFreshReadURL = true;
                                        return await response.blob();
                                    } else {
                                        console.warn('[Editor]: ‚ö†Ô∏è stat() did not return readURL, will try path or fallback');
                                        // If stat() returns path, use it for SDK read
                                        if (statResult && (statResult.path || (statResult.result && statResult.result.path))) {
                                            const statPath = statResult.path || statResult.result.path;
                                            if (statPath) {
                                                console.log('[Editor]: ‚úÖ Using path from stat():', statPath);
                                                pathToRead = statPath;
                                            }
                                        }
                                    }
                                } catch (err) {
                                    console.error('[Editor]: ‚ùå Failed to get fresh metadata from stat(), will fallback:', err);
                                }
                            }
                            
                            // Priority 2: Use readURL from URL params (fallback for initial open - this was working before)
                            // Only use this if we didn't successfully use fresh readURL from stat()
                            if (!usedFreshReadURL) {
                                const readURL = urlParams.get('puter.item.read_url');
                                if (readURL) {
                                    console.log('[Editor]: ‚úÖ Using readURL from URL params (fallback):', readURL);
                                    try {
                                        // Add cache-busting even to fallback readURL to avoid stale content
                                        const url = new URL(readURL);
                                        url.searchParams.set('_t', Date.now());
                                        const cacheBustedURL = url.toString();
                                        console.log('[Editor]: üîÑ Fetching fallback readURL with cache-busting:', cacheBustedURL);
                                        const response = await fetch(cacheBustedURL);
                                        if (!response.ok) {
                                            throw new Error(`Failed to read file: ${response.statusText}`);
                                        }
                                        return await response.blob();
                                    } catch (err) {
                                        console.error('[Editor]: ‚ùå Failed to fetch from readURL, falling back to path:', err);
                                    }
                                }
                            }
                            
                            // Priority 3: Use fullPath from URL parameters (convert to full path for SDK)
                            const fullPath = urlParams.get('puter.item.fullPath');
                            if (fullPath) {
                                console.log('[Editor]: ‚úÖ Using fullPath from URL:', fullPath);
                                pathToRead = fullPath;
                            } else {
                                // Fallback: try to get it from the current user's home directory
                                if (pathToRead && pathToRead.startsWith('~/')) {
                                    // ~/Desktop/file.txt -> /{username}/Desktop/file.txt
                                    const username = urlParams.get('puter.auth.username') || 
                                                    (window.user && window.user.username);
                                    
                                    if (username) {
                                        const relativePath = pathToRead.replace(/^~\//, '');
                                        pathToRead = `/${username}/${relativePath}`;
                                        console.log('[Editor]: ‚úÖ Converted ~ path using username:', pathToRead);
                                    } else {
                                        console.warn('[Editor]: ‚ö†Ô∏è Could not convert ~ path, using as-is (may fail)');
                                    }
                                }
                            }
                        }
                        
                        // Call original read with converted path
                        if (typeof options === 'string') {
                            return await originalRead(pathToRead);
                        } else if (options && typeof options === 'object') {
                            return await originalRead({ ...options, path: pathToRead });
                        } else {
                            return await originalRead(options);
                        }
                    };
                    console.log('[Editor]: ‚úÖ Patched puter.fs.read() to handle ~ paths');
                }
                
                // Patch puter.ui methods to ensure appInstanceID is included and add debugging
                if (appInstanceId && puter && puter.ui) {
                    console.log('[Editor]: üîß Patching puter.ui methods, appInstanceID:', appInstanceId);
                    
                    // Patch showSaveFilePicker to ensure .txt extension is added and store path
                    if (puter.ui.showSaveFilePicker) {
                        const originalShowSaveFilePicker = puter.ui.showSaveFilePicker.bind(puter.ui);
                        puter.ui.showSaveFilePicker = async function(options = {}) {
                            console.log('[Editor]: üì§ showSaveFilePicker called with options:', options);
                            console.log('[Editor]: üîç puter.ui.appInstanceID:', puter.ui.appInstanceID);
                            
                            // Ensure suggestedName has .txt extension if no extension provided
                            if (options.suggestedName && !options.suggestedName.includes('.')) {
                                options.suggestedName = options.suggestedName + '.txt';
                                console.log('[Editor]: ‚úÖ Added .txt extension to suggestedName:', options.suggestedName);
                            }
                            
                            const result = await originalShowSaveFilePicker(options);
                            
                            // Store path in the file object for later use
                            if (result && result.saved_file && result.saved_file.path) {
                                result.path = result.saved_file.path;
                                console.log('[Editor]: ‚úÖ Stored path in file object:', result.path);
                            }
                            
                            return result;
                        };
                    }
                    
                    // Patch showOpenFilePicker
                    if (puter.ui.showOpenFilePicker) {
                        const originalShowOpenFilePicker = puter.ui.showOpenFilePicker.bind(puter.ui);
                        puter.ui.showOpenFilePicker = function(...args) {
                            console.log('[Editor]: üì§ showOpenFilePicker called');
                            console.log('[Editor]: üîç puter.ui.appInstanceID:', puter.ui.appInstanceID);
                            const result = originalShowOpenFilePicker(...args);
                            // Try to manually send postMessage as fallback
                            try {
                                const message = {
                                    msg: 'showOpenFilePicker',
                                    appInstanceID: puter.ui.appInstanceID || window.puterAppInstanceID,
                                    env: 'app'
                                };
                                console.log('[Editor]: üöÄ Attempting manual postMessage:', message);
                                window.parent.postMessage(message, '*');
                                console.log('[Editor]: ‚úÖ Manual postMessage sent successfully');
                            } catch (e) {
                                console.error('[Editor]: ‚ùå Manual postMessage failed:', e);
                            }
                            return result;
                        };
                    }
                    
                    console.log('[Editor]: ‚úÖ SDK patched with manual postMessage fallback');
                }
            }
            
            initializeSDK();
        })();
    </script>
    <script>
        // CRITICAL: Initialize curfile from URL parameters when editor loads
        // When a file is opened via URL parameters (puter.item.*), the editor doesn't call open_file()
        // So we need to create curfile from URL parameters and ensure path is set
        (function() {
            function initializeCurfileFromURL() {
                const urlParams = new URLSearchParams(window.location.search);
                const itemPath = urlParams.get('puter.item.path');
                const itemName = urlParams.get('puter.item.name');
                const itemUid = urlParams.get('puter.item.uid');
                
                if (itemPath && typeof puter !== 'undefined' && puter.fs) {
                    console.log('[Editor]: üîç Found file in URL parameters:', { path: itemPath, name: itemName, uid: itemUid });
                    
                    // Wait for editor.js to load and curfile to be available
                    if (typeof curfile === 'undefined') {
                        setTimeout(initializeCurfileFromURL, 100);
                        return;
                    }
                    
                    // CRITICAL: Always ensure curfile.path is set from URL parameters
                    // Even if curfile already exists (from editor.js initialization),
                    // we need to ensure it has the correct path for subsequent saves
                    console.log('[Editor]: üìù Ensuring curfile.path is set from URL parameters');
                    console.log('[Editor]: üîç Current curfile state:', curfile ? {
                        hasPath: !!curfile.path,
                        path: curfile.path,
                        name: curfile.name,
                        hasWrite: typeof curfile.write === 'function'
                    } : 'null');
                    
                    if (!curfile) {
                        console.log('[Editor]: üìù Creating curfile from URL parameters (curfile is null)');
                        
                        // Create a file-like object that matches FSItem structure
                        const fileObj = {
                            path: itemPath, // This is the privacy-aware path like ~/Desktop/file.txt
                            name: itemName || 'Untitled.txt',
                            uid: itemUid,
                            read: async function() {
                                // Use puter.fs.read to read the file
                                return await puter.fs.read(this.path);
                            },
                            write: async function(data) {
                                // Use puter.fs.write to write the file (this is what the official SDK does)
                                console.log('[Editor]: üíæ fileObj.write() called with path:', this.path);
                                return await puter.fs.write(this.path, data, { overwrite: true });
                            }
                        };
                        
                        // Set curfile to the file object
                        curfile = fileObj;
                        console.log('[Editor]: ‚úÖ curfile created from URL parameters:', {
                            path: curfile.path,
                            name: curfile.name,
                            uid: curfile.uid
                        });
                    } else {
                        // curfile exists, but we MUST ensure path is set correctly
                        console.log('[Editor]: üîß curfile exists, ensuring path is set correctly');
                        
                        // Always set path from URL parameters (this is the source of truth)
                        if (itemPath) {
                            curfile.path = itemPath;
                            console.log('[Editor]: ‚úÖ Set curfile.path from URL parameters:', curfile.path);
                        }
                        
                        // Ensure write method exists and uses the correct path
                        if (!curfile.write || typeof curfile.write !== 'function') {
                            console.log('[Editor]: ‚ö†Ô∏è curfile.write() missing, adding write method');
                            curfile.write = async function(data) {
                                console.log('[Editor]: üíæ curfile.write() called with path:', this.path);
                                if (!this.path) {
                                    console.error('[Editor]: ‚ùå CRITICAL: this.path is not set in write()!');
                                    throw new Error('File path is not set');
                                }
                                return await puter.fs.write(this.path, data, { overwrite: true });
                            };
                        } else {
                            // Replace write method entirely to ensure it uses the correct path
                            // The original write() might not use this.path correctly
                            console.log('[Editor]: üîß Replacing curfile.write() to ensure path is used correctly');
                            curfile.write = async function(data) {
                                console.log('[Editor]: üíæ curfile.write() called (replaced)');
                                console.log('[Editor]: üîç this.path:', this.path);
                                console.log('[Editor]: üîç itemPath from URL:', itemPath);
                                
                                // CRITICAL: Use path from URL parameters (source of truth)
                                const writePath = this.path || itemPath;
                                
                                if (!writePath) {
                                    console.error('[Editor]: ‚ùå CRITICAL: No path available for write!');
                                    console.error('[Editor]: ‚ùå this.path:', this.path);
                                    console.error('[Editor]: ‚ùå itemPath:', itemPath);
                                    throw new Error('File path is not set');
                                }
                                
                                // Ensure this.path is set for future calls
                                if (!this.path && itemPath) {
                                    this.path = itemPath;
                                    console.log('[Editor]: ‚úÖ Set this.path for future calls:', this.path);
                                }
                                
                                // Log data being written
                                const dataType = data instanceof Blob ? 'Blob' : typeof data;
                                const dataSize = data instanceof Blob ? data.size : (typeof data === 'string' ? data.length : 'unknown');
                                console.log('[Editor]: üìù Data to write - type:', dataType, 'size:', dataSize);
                                if (typeof data === 'string' && data.length < 200) {
                                    console.log('[Editor]: üìù Data preview:', data.substring(0, 100));
                                }
                                
                                // Try using writeURL from URL params first (this goes through proper overwrite handler)
                                const urlParams = new URLSearchParams(window.location.search);
                                const writeURL = urlParams.get('puter.item.write_url');
                                
                                if (writeURL) {
                                    console.log('[Editor]: ‚úÖ Using writeURL from URL params for overwrite:', writeURL);
                                    try {
                                        // Convert data to Blob if it's a string
                                        const blobData = typeof data === 'string' ? new Blob([data], { type: 'text/plain' }) : data;
                                        
                                        const response = await fetch(writeURL, {
                                            method: 'PUT',
                                            body: blobData,
                                            headers: {
                                                'Content-Type': blobData.type || 'text/plain'
                                            }
                                        });
                                        
                                        if (!response.ok) {
                                            const errorText = await response.text();
                                            throw new Error(`Write failed: ${response.status} ${response.statusText} - ${errorText}`);
                                        }
                                        
                                        const writeResult = await response.json().catch(() => ({ success: true }));
                                        console.log('[Editor]: ‚úÖ Write via writeURL completed successfully');
                                        console.log('[Editor]: üìä Write result:', writeResult);
                                        
                                        // Verify immediately after write
                                        console.log('[Editor]: üîç Verifying write by reading file back with fresh readURL...');
                                        try {
                                            // Get fresh readURL using stat() with path
                                            const verifyStatResult = await puter.fs.stat({ path: writePath, consistency: 'strong' });
                                            console.log('[Editor]: üìä Verification stat() result:', verifyStatResult);
                                            
                                            // Extract readURL from stat result
                                            let freshReadURL = null;
                                            if (verifyStatResult && verifyStatResult.readURL) {
                                                freshReadURL = verifyStatResult.readURL;
                                            } else if (verifyStatResult && verifyStatResult.read_url) {
                                                freshReadURL = verifyStatResult.read_url;
                                            } else if (verifyStatResult && verifyStatResult.result && verifyStatResult.result.readURL) {
                                                freshReadURL = verifyStatResult.result.readURL;
                                            } else if (verifyStatResult && verifyStatResult.result && verifyStatResult.result.read_url) {
                                                freshReadURL = verifyStatResult.result.read_url;
                                            }
                                            
                                            if (freshReadURL) {
                                                console.log('[Editor]: ‚úÖ Got fresh readURL for verification:', freshReadURL);
                                                // Add cache-busting
                                                const url = new URL(freshReadURL);
                                                url.searchParams.set('_t', Date.now());
                                                const verifyResponse = await fetch(url.toString());
                                                if (!verifyResponse.ok) {
                                                    throw new Error(`Failed to verify: ${verifyResponse.statusText}`);
                                                }
                                                const verifyContent = await verifyResponse.text();
                                                console.log('[Editor]: ‚úÖ Verification read successful (fresh), content length:', verifyContent ? verifyContent.length : 0);
                                                
                                                // Compare with what we wrote
                                                const writtenContent = typeof data === 'string' ? data : (data instanceof Blob ? await data.text() : String(data));
                                                if (verifyContent === writtenContent) {
                                                    console.log('[Editor]: ‚úÖ VERIFICATION PASSED: Written content matches read content!');
                                                } else {
                                                    console.warn('[Editor]: ‚ö†Ô∏è VERIFICATION MISMATCH: Written length:', writtenContent.length, 'Read length:', verifyContent.length);
                                                    console.warn('[Editor]: ‚ö†Ô∏è Written preview:', writtenContent.substring(0, 50));
                                                    console.warn('[Editor]: ‚ö†Ô∏è Read preview:', verifyContent.substring(0, 50));
                                                }
                                            }
                                        } catch (verifyErr) {
                                            console.error('[Editor]: ‚ùå Verification read failed:', verifyErr);
                                        }
                                        
                                        return { success: true, path: writePath, ...writeResult };
                                    } catch (writeURLErr) {
                                        console.error('[Editor]: ‚ùå Write via writeURL failed, falling back to puter.fs.write():', writeURLErr);
                                        // Fall through to puter.fs.write() below
                                    }
                                }
                                
                                console.log('[Editor]: ‚úÖ Calling puter.fs.write() with path:', writePath, 'overwrite: true');
                                try {
                                    const writeResult = await puter.fs.write(writePath, data, { overwrite: true });
                                    console.log('[Editor]: ‚úÖ puter.fs.write() completed successfully');
                                    console.log('[Editor]: üìä Write result:', writeResult);
                                    console.log('[Editor]: üìä Write result keys:', writeResult ? Object.keys(writeResult) : 'null');
                                    
                                    // Verify the write by reading back immediately with FRESH readURL
                                    console.log('[Editor]: üîç Verifying write by reading file back with fresh readURL...');
                                    try {
                                        // Get fresh readURL using stat() with path (not uid, since we just wrote to this path)
                                        let freshReadURL = null;
                                        try {
                                            const verifyStatResult = await puter.fs.stat({ path: writePath, consistency: 'strong' });
                                            console.log('[Editor]: üìä Verification stat() result:', verifyStatResult);
                                            
                                            // Extract readURL from stat result
                                            if (verifyStatResult && verifyStatResult.readURL) {
                                                freshReadURL = verifyStatResult.readURL;
                                            } else if (verifyStatResult && verifyStatResult.read_url) {
                                                freshReadURL = verifyStatResult.read_url;
                                            } else if (verifyStatResult && verifyStatResult.result && verifyStatResult.result.readURL) {
                                                freshReadURL = verifyStatResult.result.readURL;
                                            } else if (verifyStatResult && verifyStatResult.result && verifyStatResult.result.read_url) {
                                                freshReadURL = verifyStatResult.result.read_url;
                                            }
                                            
                                            if (freshReadURL) {
                                                console.log('[Editor]: ‚úÖ Got fresh readURL for verification:', freshReadURL);
                                                // Add cache-busting
                                                const url = new URL(freshReadURL);
                                                url.searchParams.set('_t', Date.now());
                                                const response = await fetch(url.toString());
                                                if (!response.ok) {
                                                    throw new Error(`Failed to verify: ${response.statusText}`);
                                                }
                                                const verifyContent = await response.text();
                                                console.log('[Editor]: ‚úÖ Verification read successful (fresh), content length:', verifyContent ? verifyContent.length : 0);
                                                if (typeof verifyContent === 'string' && verifyContent.length < 200) {
                                                    console.log('[Editor]: üìù Verified content preview:', verifyContent.substring(0, 100));
                                                }
                                                
                                                // Compare with what we wrote
                                                const writtenContent = typeof data === 'string' ? data : (data instanceof Blob ? await data.text() : String(data));
                                                if (verifyContent === writtenContent) {
                                                    console.log('[Editor]: ‚úÖ VERIFICATION PASSED: Written content matches read content!');
                                                } else {
                                                    console.warn('[Editor]: ‚ö†Ô∏è VERIFICATION MISMATCH: Written length:', writtenContent.length, 'Read length:', verifyContent.length);
                                                    console.warn('[Editor]: ‚ö†Ô∏è Written preview:', writtenContent.substring(0, 50));
                                                    console.warn('[Editor]: ‚ö†Ô∏è Read preview:', verifyContent.substring(0, 50));
                                                }
                                            } else {
                                                console.warn('[Editor]: ‚ö†Ô∏è stat() did not return readURL for verification, using puter.fs.read()');
                                                const verifyRead = await puter.fs.read(writePath);
                                                const verifyContent = verifyRead instanceof Blob ? await verifyRead.text() : verifyRead;
                                                console.log('[Editor]: ‚úÖ Verification read successful, content length:', verifyContent ? verifyContent.length : 0);
                                                if (typeof verifyContent === 'string' && verifyContent.length < 200) {
                                                    console.log('[Editor]: üìù Verified content preview:', verifyContent.substring(0, 100));
                                                }
                                            }
                                        } catch (statErr) {
                                            console.error('[Editor]: ‚ùå Failed to get fresh readURL for verification, using puter.fs.read():', statErr);
                                            const verifyRead = await puter.fs.read(writePath);
                                            const verifyContent = verifyRead instanceof Blob ? await verifyRead.text() : verifyRead;
                                            console.log('[Editor]: ‚úÖ Verification read successful, content length:', verifyContent ? verifyContent.length : 0);
                                            if (typeof verifyContent === 'string' && verifyContent.length < 200) {
                                                console.log('[Editor]: üìù Verified content preview:', verifyContent.substring(0, 100));
                                            }
                                        }
                                    } catch (verifyErr) {
                                        console.error('[Editor]: ‚ùå Verification read failed:', verifyErr);
                                    }
                                    
                                    return writeResult;
                                } catch (writeErr) {
                                    console.error('[Editor]: ‚ùå puter.fs.write() failed:', writeErr);
                                    console.error('[Editor]: ‚ùå Error details:', {
                                        message: writeErr.message,
                                        stack: writeErr.stack,
                                        path: writePath,
                                        dataType: dataType,
                                        dataSize: dataSize
                                    });
                                    throw writeErr;
                                }
                            };
                            console.log('[Editor]: ‚úÖ Replaced curfile.write() to use path correctly');
                        }
                        
                        console.log('[Editor]: ‚úÖ curfile verified and patched:', {
                            path: curfile.path,
                            name: curfile.name,
                            hasWrite: typeof curfile.write === 'function'
                        });
                    }
                } else if (itemPath) {
                    // URL params exist but SDK not ready yet, retry
                    setTimeout(initializeCurfileFromURL, 100);
                }
            }
            
            // Start initialization after a short delay to ensure SDK is loaded
            setTimeout(initializeCurfileFromURL, 500);
        })();
    </script>
    <script src="./js/printjs.min.js"></script>
    <script src="./js/html-entities.js"></script>
    <script src="./js/jquery-3.6.0.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script>
    <script src="./js/monaco-editor/min/vs/loader.js"></script>
    <script>
        // Configure Monaco Editor to load from local files (self-hosted)
        if (typeof require !== 'undefined' && require.config) {
            require.config({ 
                paths: { 
                    'vs': './js/monaco-editor/min/vs'
                }
            });
        }
    </script>
    <script src="./js/editor.js"></script>
    <script>
        // Ensure curfile.path is always set (matching official Puter SDK behavior)
        // The official SDK's File.write() method uses this.path, so it must be set
        // Official implementation: curfile.write(data) -> puter.fs.write(this.path, ...)
        
        // Patch save_file to add debugging and verify path is set
        (function() {
            function patchSaveFile() {
                if (typeof save_file === 'undefined') {
                    setTimeout(patchSaveFile, 50);
                    return;
                }
                
                const originalSaveFile = save_file;
                window.save_file = async function(callback) {
                    console.log('[Editor]: üíæ save_file() called');
                    console.log('[Editor]: üîç curfile:', curfile ? {
                        path: curfile.path,
                        name: curfile.name,
                        uid: curfile.uid,
                        hasWrite: typeof curfile.write === 'function',
                        hasPath: !!curfile.path
                    } : 'null');
                    
                    if (!curfile) {
                        console.error('[Editor]: ‚ùå curfile is null/undefined!');
                        return originalSaveFile.call(this, callback);
                    }
                    
                    if (!curfile.path) {
                        console.error('[Editor]: ‚ùå curfile.path is not set! This will cause write() to fail!');
                        console.error('[Editor]: ‚ùå curfile object:', curfile);
                        // Try to get path from saved_file
                        if (curfile.saved_file && curfile.saved_file.path) {
                            curfile.path = curfile.saved_file.path;
                            console.log('[Editor]: ‚úÖ Recovered path from saved_file:', curfile.path);
                        } else {
                            console.error('[Editor]: ‚ùå Cannot recover path, save will fail!');
                            return originalSaveFile.call(this, callback);
                        }
                    }
                    
                    console.log('[Editor]: ‚úÖ curfile.path is set, calling curfile.write() with path:', curfile.path);
                    return originalSaveFile.call(this, callback);
                };
                console.log('[Editor]: ‚úÖ save_file() patched with debugging');
            }
            setTimeout(patchSaveFile, 200);
        })();
        
        // Listen for fileSaved messages to ensure path is stored in curfile
        // This ensures curfile.path is set after first save, so subsequent saves work
        window.addEventListener('message', function(event) {
            if (event.data && event.data.msg === 'fileSaved' && event.data.saved_file) {
                console.log('[Editor]: üì• Received fileSaved message, path:', event.data.saved_file.path);
                // Store path in curfile if it exists (matching official Puter SDK)
                // The official SDK's File.write() uses this.path, so it must be set
                if (typeof curfile !== 'undefined' && curfile) {
                    curfile.path = event.data.saved_file.path;
                    curfile.saved_file = event.data.saved_file;
                    console.log('[Editor]: ‚úÖ Stored path in curfile (matching official SDK):', curfile.path);
                    console.log('[Editor]: üîç curfile after fileSaved:', {
                        path: curfile.path,
                        name: curfile.name,
                        uid: curfile.uid,
                        hasWrite: typeof curfile.write === 'function'
                    });
                }
            }
        });
        
        // Patch open_file to ensure curfile is set and path is available
        // CRITICAL BUG FIX: open_file() doesn't set curfile = cfile, so save_file() fails
        // The official Puter SDK's File.write() uses this.path, so curfile must be set correctly
        (function() {
            function patchOpenFile() {
                if (typeof open_file === 'undefined') {
                    setTimeout(patchOpenFile, 50);
                    return;
                }
                
                const originalOpenFile = open_file;
                window.open_file = async function(cfile) {
                    console.log('[Editor]: üìÇ open_file() called');
                    console.log('[Editor]: üîç cfile properties:', cfile ? Object.keys(cfile) : 'null');
                    console.log('[Editor]: üîç cfile.path:', cfile?.path);
                    console.log('[Editor]: üîç cfile.fsentry_path:', cfile?.fsentry_path);
                    console.log('[Editor]: üîç cfile type:', cfile?.constructor?.name);
                    
                    // CRITICAL: Set curfile to the opened file (this was missing!)
                    // Without this, save_file() uses the wrong file object
                    curfile = cfile;
                    console.log('[Editor]: ‚úÖ Set curfile to opened file');
                    
                    // The official Puter SDK creates FSItem objects from fileOpenPicked
                    // FSItem constructor sets: this.path = options.path ?? options.fsentry_path
                    // So cfile should already have a path property if it's a proper FSItem
                    // But we'll ensure it's set anyway for robustness
                    if (cfile) {
                        // Check if path exists (FSItem should have it from constructor)
                        if (!cfile.path) {
                            // Try to get path from various possible locations (matching FSItem constructor logic)
                            const filePath = cfile.fsentry_path || 
                                           cfile.path ||  // Try direct path again
                                           cfile.saved_file?.path || 
                                           (cfile.saved_file && cfile.saved_file.path);
                            
                            if (filePath) {
                                cfile.path = filePath;
                                curfile.path = filePath;
                                console.log('[Editor]: ‚úÖ Set path from fallback sources:', filePath);
                            } else {
                                console.error('[Editor]: ‚ùå No path found in file object!', cfile);
                                console.error('[Editor]: ‚ùå Full cfile object:', JSON.stringify(cfile, null, 2));
                            }
                        } else {
                            // Path already exists, ensure curfile has it too
                            curfile.path = cfile.path;
                            console.log('[Editor]: ‚úÖ Path already set on file object:', cfile.path);
                        }
                        
                        // Final verification: ensure curfile.path is set before proceeding
                        if (!curfile.path) {
                            console.error('[Editor]: ‚ùå CRITICAL: curfile.path is still not set after all attempts!');
                            console.error('[Editor]: ‚ùå This will cause save_file() to fail!');
                        } else {
                            console.log('[Editor]: ‚úÖ Verified curfile.path is set:', curfile.path);
                        }
                    }
                    
                    return originalOpenFile.call(this, cfile);
                };
                console.log('[Editor]: ‚úÖ open_file() patched to set curfile and ensure path');
            }
            setTimeout(patchOpenFile, 200);
        })();
    </script>
</body>

</html>